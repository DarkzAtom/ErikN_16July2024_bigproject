i need to realise the following with my program:
1) a general (this is how i will call it from time to time, meaning commonly-shared between all the machines that are using the program) queue in the firestore
2) the tasks are added to it with the FIFO sequence
3) a separate process on each machine, that doesn't block the main one checks periodically if the the first task in the queue is theirs. meaning, that diff machines will sent to the commonly-shared queue tasks, but they will execute only their resp.ones they've sent. IF the machine detects, that it is their task is the first in the line, then this machine will execute in the program the sequence of commands to search for the free accounts, and is responsible to send this task to the execution. the process of it will be described in the step 4. If the program on any machine is getting closed, then it must clear all its process that were in the queue beforehand
4) the task in the common queue that is the first in line is checking periodically if there are enough free accounts to execute the task (1acc - one like). if there is, it takes those free accounts, saves their creds into the list and passes it as a result to the subprocess init_tiktok_scrape. If there are less accounts (busy and free) in the whole list then the amount of likes that have been passed with the task, then it must throw an exception (show an error with the QtCritical) to set the amount accordingly and the current actual amount of all accounts in the list. it happens before adding to the general queue. so every task before adding should be checked on that. 
5) then in the created subprocess the worker with the concurrent.futures will be executing all the likes. 

N.B.: while the tasks are awaiting in the queue - their will have the according status, i.e. "waiting in the queue". once it sent to the execution, the status changes to the "in process"
